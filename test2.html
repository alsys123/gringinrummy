<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>3D House</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #cce0ff;
  }
</style>
</head>
<body>

<!-- three.js + OrbitControls -->
<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<script>
/* -------------------------------------------------------
   FIXED CONTAINER (works on GitHub Pages + Google Sites)
------------------------------------------------------- */
const container = document.createElement("div");
container.style.position = "fixed";
container.style.top = "0";
container.style.left = "0";
container.style.width = "100%";
container.style.height = "100%";
document.body.appendChild(container);

/* -------------------------------------------------------
   BASIC THREE.JS SETUP
------------------------------------------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0c4ff);

const camera = new THREE.PerspectiveCamera(
  60,
  container.clientWidth / container.clientHeight,
  0.1,
  500
);
camera.position.set(20, 20, 20);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);
controls.update();

/* -------------------------------------------------------
   LIGHTING
------------------------------------------------------- */
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
scene.add(light);

scene.add(new THREE.AmbientLight(0xffffff, 0.4));

/* -------------------------------------------------------
   GROUND PLANE
------------------------------------------------------- */
const groundGeo = new THREE.PlaneGeometry(200, 200);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x88aa88 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
scene.add(ground);

/* -------------------------------------------------------
   SECTIONS
------------------------------------------------------- */
const sections = {
  walls: new THREE.Group(),
  roof: new THREE.Group(),
  garage: new THREE.Group(),
  yard: new THREE.Group(),
  fence: new THREE.Group(),
  backyard: new THREE.Group()
};

Object.values(sections).forEach(s => scene.add(s));

/* -------------------------------------------------------
   GEOMETRIES & MATERIALS
------------------------------------------------------- */
const wallGeo     = new THREE.BoxGeometry(1, 2, 0.2);
const roofGeo     = new THREE.BoxGeometry(1, 0.5, 1);
const garageGeo   = new THREE.BoxGeometry(1.2, 1, 1);
const carGeo      = new THREE.BoxGeometry(1, 0.5, 0.5);
const yardGeo     = new THREE.BoxGeometry(1, 0.1, 1);
const fenceGeo    = new THREE.BoxGeometry(0.1, 1, 1);
const backyardGeo = new THREE.BoxGeometry(1, 0.1, 1);

const wallMat     = new THREE.MeshStandardMaterial({ color: 0xffffff });
const roofMat     = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
const garageMat   = new THREE.MeshStandardMaterial({ color: 0xcccccc });
const carMat      = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const yardMat     = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
const fenceMat    = new THREE.MeshStandardMaterial({ color: 0x996633 });
const backyardMat = new THREE.MeshStandardMaterial({ color: 0x447744 });

/* -------------------------------------------------------
   BUILD A SECTION (10 parts Ã— 5 pieces)
------------------------------------------------------- */
function buildSection(group, geo, mat, baseX, baseZ, dx, dz, yOffset = 0) {
  for (let part = 0; part < 10; part++) {
    const partGroup = new THREE.Group();
    partGroup.position.set(
      baseX + part * dx,
      yOffset,
      baseZ + part * dz
    );

    for (let piece = 0; piece < 5; piece++) {
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.x = piece * 1.2;
      partGroup.add(mesh);
    }

    group.add(partGroup);
  }
}

/* -------------------------------------------------------
   PLACE SECTIONS AROUND ORIGIN
------------------------------------------------------- */
buildSection(sections.walls, wallGeo, wallMat, -3, -3, 0, 0.8, 1);
buildSection(sections.roof, roofGeo, roofMat, -3, -3, 0, 0.8, 3.2);

buildSection(sections.garage, garageGeo, garageMat, 4, -2, 0, 0.8, 1);
const car = new THREE.Mesh(carGeo, carMat);
car.position.set(4, 0.25, -4);
sections.garage.add(car);

buildSection(sections.yard, yardGeo, yardMat, -2, 4, 0.8, 0, 0.05);
buildSection(sections.fence, fenceGeo, fenceMat, -8, 0, 0.8, 0, 0.5);
buildSection(sections.backyard, backyardGeo, backyardMat, -2, -8, 0.8, 0, 0.05);

/* -------------------------------------------------------
   RENDER LOOP
------------------------------------------------------- */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

/* -------------------------------------------------------
   RESIZE HANDLER
------------------------------------------------------- */
window.addEventListener("resize", () => {
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});
</script>

</body>
</html>
