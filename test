<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>3D House Hierarchy</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #e0e0e0;
  }
</style>
</head>
<body>

<!-- three.js + OrbitControls from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/controls/OrbitControls.js"></script>

<script>
/* -------------------------------------------------------
   CONTAINER FOR GOOGLE SITES
------------------------------------------------------- */
const container = document.createElement("div");
container.style.position = "fixed";
container.style.top = "0";
container.style.left = "0";
container.style.width = "100%";
container.style.height = "100%";
document.body.appendChild(container);

/* -------------------------------------------------------
   BASIC THREE.JS SETUP
------------------------------------------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0c4ff);

const camera = new THREE.PerspectiveCamera(
  60,
  container.clientWidth / container.clientHeight,
  0.1,
  500
);
camera.position.set(18, 18, 18);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);
controls.update();

/* -------------------------------------------------------
   LIGHTING
------------------------------------------------------- */
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));

/* -------------------------------------------------------
   GROUND PLANE (for context)
------------------------------------------------------- */
const groundGeo = new THREE.PlaneGeometry(80, 80);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x88aa88 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
scene.add(ground);

/* -------------------------------------------------------
   SECTION STRUCTURE
   6 sections → each has 10 parts → each has 5 pieces
   1 = walls
   2 = roof
   3 = detached garage + car
   4 = yard
   5 = fence
   6 = backyard
------------------------------------------------------- */
const sections = {
  walls: new THREE.Group(),
  roof: new THREE.Group(),
  garage: new THREE.Group(),
  yard: new THREE.Group(),
  fence: new THREE.Group(),
  backyard: new THREE.Group()
};

scene.add(sections.walls);
scene.add(sections.roof);
scene.add(sections.garage);
scene.add(sections.yard);
scene.add(sections.fence);
scene.add(sections.backyard);

/* -------------------------------------------------------
   GEOMETRIES & MATERIALS
------------------------------------------------------- */
const wallGeo     = new THREE.BoxGeometry(1, 2, 0.2);
const roofGeo     = new THREE.BoxGeometry(1, 0.5, 1);
const garageGeo   = new THREE.BoxGeometry(1.2, 1, 1);
const carGeo      = new THREE.BoxGeometry(1, 0.5, 0.5);
const yardGeo     = new THREE.BoxGeometry(1, 0.1, 1);
const fenceGeo    = new THREE.BoxGeometry(0.1, 1, 1);
const backyardGeo = new THREE.BoxGeometry(1, 0.1, 1);

const wallMat     = new THREE.MeshStandardMaterial({ color: 0xffffff });
const roofMat     = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
const garageMat   = new THREE.MeshStandardMaterial({ color: 0xcccccc });
const carMat      = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const yardMat     = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
const fenceMat    = new THREE.MeshStandardMaterial({ color: 0x996633 });
const backyardMat = new THREE.MeshStandardMaterial({ color: 0x447744 });

/* -------------------------------------------------------
   HELPER: BUILD A SECTION (10 parts × 5 pieces)
------------------------------------------------------- */
function buildSection(group, geo, mat, baseX, baseZ, dx, dz, yOffset = 0) {
  for (let part = 0; part < 10; part++) {
    const partGroup = new THREE.Group();
    partGroup.position.set(
      baseX + part * dx,
      yOffset,
      baseZ + part * dz
    );

    for (let piece = 0; piece < 5; piece++) {
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.x = piece * 1.2;
      partGroup.add(mesh);
    }

    group.add(partGroup);
  }
}

/* -------------------------------------------------------
   PLACE SECTIONS TIGHTLY AROUND ORIGIN
------------------------------------------------------- */
// Walls around origin
buildSection(sections.walls, wallGeo, wallMat, -3, -3, 0, 0.8, 1);

// Roof slightly above walls
buildSection(sections.roof, roofGeo, roofMat, -3, -3, 0, 0.8, 3.2);

// Garage cluster to the right
buildSection(sections.garage, garageGeo, garageMat, 4, -2, 0, 0.8, 1);

// Car in front of garage
const car = new THREE.Mesh(carGeo, carMat);
car.position.set(4, 0.25, -4);
sections.garage.add(car);

// Yard in front
buildSection(sections.yard, yardGeo, yardMat, -2, 4, 0.8, 0, 0.05);

// Fence around front/side
buildSection(sections.fence, fenceGeo, fenceMat, -8, 0, 0.8, 0, 0.5);

// Backyard behind house
buildSection(sections.backyard, backyardGeo, backyardMat, -2, -8, 0.8, 0, 0.05);

/* -------------------------------------------------------
   OPTIONAL: "BUILD WITH N PIECES" LOGIC (ALL ON BY DEFAULT)
   You can call setBuiltPieceCount(n) from code later if needed.
------------------------------------------------------- */
function setBuiltPieceCount(targetCount) {
  let count = 0;
  const sectionOrder = [
    sections.walls,
    sections.roof,
    sections.garage,
    sections.yard,
    sections.fence,
    sections.backyard
  ];

  for (const section of sectionOrder) {
    for (const part of section.children) {
      for (const piece of part.children) {
        const visible = count < targetCount;
        piece.visible = visible;
        count++;
        if (count >= targetCount) return;
      }
    }
  }
}
// By default, everything is visible; no call here.

/* -------------------------------------------------------
   RENDER LOOP
------------------------------------------------------- */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

/* -------------------------------------------------------
   RESIZE HANDLER
------------------------------------------------------- */
window.addEventListener("resize", () => {
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});
</script>

</body>
</html>
